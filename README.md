# ğŸ“˜ IntroduÃ§Ã£o a Estruturas de Dados em C â€” Resumo por CapÃ­tulo (2Âª ed.)

Este repositÃ³rio contÃ©m resoluÃ§Ãµes dos exercÃ­cios do livro *IntroduÃ§Ã£o a Estruturas de Dados â€” com tÃ©cnicas de programaÃ§Ã£o em C* (2Âª ed.). 

---

## ğŸ”¹ CapÃ­tulo 1 â€“ IntroduÃ§Ã£o Ã  programaÃ§Ã£o
- Apresenta objetivos do livro e motivaÃ§Ã£o para estudar estruturas de dados.  
- Conceitos bÃ¡sicos de algoritmo e representaÃ§Ã£o de dados.  
- NoÃ§Ãµes iniciais sobre anÃ¡lise de eficiÃªncia.  
- Prepara para as estruturas estÃ¡ticas abordadas a seguir.  

---

## ğŸ§¾ CapÃ­tulo 2 â€“ VariÃ¡veis e operadores
1. Tipos de dados primitivos em C.  
2. DeclaraÃ§Ã£o, atribuiÃ§Ã£o e conversÃµes.  
3. Operadores aritmÃ©ticos, relacionais e lÃ³gicos.  
4. Regras de precedÃªncia e boas prÃ¡ticas.  

---

## ğŸ” CapÃ­tulo 3 â€“ Condicionais
- Estruturas if/else e switch-case.  
- AvaliaÃ§Ã£o de expressÃµes lÃ³gicas e decisÃµes de fluxo.  
- Tratamento de caminhos alternativos em algoritmos.  
- Exemplos prÃ¡ticos aplicados a problemas simples.  

---

## âš™ï¸ CapÃ­tulo 4 â€“ FunÃ§Ãµes e ponteiros
- DefiniÃ§Ã£o e modularizaÃ§Ã£o via funÃ§Ãµes em C.  
- Passagem por valor vs. referÃªncia com ponteiros.  
- Assinaturas, protÃ³tipos e escopo de variÃ¡veis.  
- Uso de ponteiros para manipular estruturas e arrays.  

---

## ğŸ” CapÃ­tulo 5 â€“ RepetiÃ§Ãµes
â¡ï¸ ConteÃºdo:  
1. LaÃ§os while, do-while e for.  
2. Controle de iteraÃ§Ãµes (break/continue).  
3. Estruturas para percorrer arrays e listas.  
4. AplicaÃ§Ãµes em algoritmos iterativos.  

---

## ğŸ”¢ CapÃ­tulo 6 â€“ Vetores
- Conceito de arrays unidimensionais e multidimensionais.  
- IndexaÃ§Ã£o, limites e manipulaÃ§Ã£o em C.  
- OperaÃ§Ãµes bÃ¡sicas: leitura, escrita e iteraÃ§Ã£o.  
- ComparaÃ§Ã£o com estruturas dinÃ¢micas iniciais.  

---

## ğŸ§  CapÃ­tulo 7 â€“ AlocaÃ§Ã£o dinÃ¢mica
1. malloc, calloc, realloc e free.  
2. GestÃ£o de memÃ³ria e problemas comuns (vazamentos).  
3. EstratÃ©gias para estruturas variÃ¡veis.  
4. Boas prÃ¡ticas de uso em C.  

---

## ğŸ”¤ CapÃ­tulo 8 â€“ Cadeias de caracteres
- RepresentaÃ§Ã£o de strings em C (vetor de chars).  
- OperaÃ§Ãµes: leitura, escrita, concatenaÃ§Ã£o e comparaÃ§Ã£o.  
- FunÃ§Ãµes da biblioteca padrÃ£o e manipulaÃ§Ã£o segura.  
- Cuidados com terminaÃ§Ã£o nula e buffer overflow.  

---

## ğŸ§© CapÃ­tulo 9 â€“ Tipos estruturados
- DefiniÃ§Ã£o e uso de `struct` e `union`.  
- Agrupamento de dados heterogÃªneos.  
- Passagem de estruturas a funÃ§Ãµes e alocaÃ§Ã£o dinÃ¢mica.  
- OrganizaÃ§Ã£o modular do cÃ³digo com tipos compostos.  

---

## ğŸ“ CapÃ­tulo 10 â€“ Arquivos
1. Entrada/saÃ­da em arquivo (fopen, fread, fwrite, fclose).  
2. Modos de abertura e posicionamento (fseek).  
3. PersistÃªncia de estruturas e formatos simples.  
4. Erros de I/O e tratamento bÃ¡sico de exceÃ§Ãµes.  

---

## ğŸ” CapÃ­tulo 11 â€“ Busca e ordenaÃ§Ã£o
- TÃ©cnicas bÃ¡sicas de busca: linear e binÃ¡ria.  
- Algoritmos de ordenaÃ§Ã£o simples e eficientes.  
- Complexidade comparativa e quando escolher cada mÃ©todo.  
- ExercÃ­cios aplicados Ã  organizaÃ§Ã£o de dados.  

---

## ğŸ§­ CapÃ­tulo 12 â€“ Tipo abstrato de dados
- Conceito de TAD: interface vs implementaÃ§Ã£o.  
- Encapsulamento e contrato de operaÃ§Ãµes.  
- Exemplos prÃ¡ticos de especificaÃ§Ã£o de TADs em C.  
- Papel do TAD na modularidade do software.  

---

## ğŸ”„ CapÃ­tulo 13 â€“ Vetores dinÃ¢micos
1. ImplementaÃ§Ã£o de vetores redimensionÃ¡veis.  
2. EstratÃ©gias de crescimento (fator de expansÃ£o).  
3. Complexidade amortizada das operaÃ§Ãµes.  
4. Uso prÃ¡tico como base para outros TADs.  

---

## ğŸ”— CapÃ­tulo 14 â€“ Listas encadeadas
- Listas simples, duplas e circulares: estrutura e nÃ³.  
- OperaÃ§Ãµes: inserÃ§Ã£o, remoÃ§Ã£o, busca e travessia.  
- Vantagens frente aos vetores para inserÃ§Ãµes/removÃ§Ãµes.  
- ImplementaÃ§Ã£o com ponteiros e gerenciamento de memÃ³ria.  

---

## ğŸ“š CapÃ­tulo 15 â€“ Pilhas e filas
- Pilha (LIFO) e fila (FIFO): definiÃ§Ãµes e usos.  
- ImplementaÃ§Ãµes por vetor e por lista encadeada.  
- AplicaÃ§Ãµes: avaliaÃ§Ã£o de expressÃµes, buffers e controle.  
- VariaÃ§Ãµes: fila circular e fila com prioridades.  

---

## ğŸŒ² CapÃ­tulo 16 â€“ Ãrvores
1. Conceito de Ã¡rvore e terminologia bÃ¡sica.  
2. RepresentaÃ§Ã£o e percursos (prÃ©/in/pÃ³s-ordem).  
3. AplicaÃ§Ãµes: expressÃ£o, indexaÃ§Ã£o e hierarquias.  
4. ImplementaÃ§Ã£o dinÃ¢mica com nÃ³s e ponteiros.  

---

## ğŸŒ± CapÃ­tulo 17 â€“ Estruturas genÃ©ricas
- Uso de tipos genÃ©ricos (void*, callbacks) em C.  
- ImplementaÃ§Ã£o de TADs reutilizÃ¡veis e flexÃ­veis.  
- Trade-offs entre tipo seguro e flexibilidade.  
- PadrÃµes para criaÃ§Ã£o de bibliotecas de estruturas.  

---

## ğŸ” CapÃ­tulo 19 â€“ Tabelas de dispersÃ£o (Hashing)
- PrincÃ­pio do hashing e funÃ§Ã£o de espalhamento.  
- Tratamento de colisÃµes: encadeamento e sondagem.  
- Fator de carga e impacto na performance.  
- AplicaÃ§Ãµes em dicionÃ¡rios e busca rÃ¡pida.  

---

## âš™ï¸ CapÃ­tulo 20 â€“ Listas de prioridade
1. Conceito de fila de prioridade e usos tÃ­picos.  
2. ImplementaÃ§Ã£o em heap (lista de prioridade).  
3. OperaÃ§Ãµes: inserÃ§Ã£o, extrair-min/max e ajuste.  
4. Complexidade e aplicaÃ§Ãµes em algoritmos gulosos.  

---

## ğŸ”— CapÃ­tulo 21 â€“ UniÃ£o e busca (Union-Find)
- Estrutura disjoint-set: make, find, union.  
- OtimizaÃ§Ãµes: compressÃ£o de caminho e union by rank.  
- Uso em componentes conectados e MST (Kruskal).  
- AnÃ¡lise amortizada e eficiÃªncia prÃ¡tica.  

---

## ğŸ”º CapÃ­tulo 22 â€“ Grafos
- Modelos: listas de adjacÃªncia e matriz de adjacÃªncia.  
- Percursos: BFS e DFS; aplicaÃ§Ãµes e propriedades.  
- Algoritmos bÃ¡sicos: caminhos, ciclos e conectividade.  
- Bases para algoritmos avanÃ§ados (MST, caminhos mÃ­nimos).  

---
